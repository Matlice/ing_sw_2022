\section{GRASP Pure Fabrication}

\begin{frame}
    \frametitle{Prima ideazione derivata dal modello di dominio}
    Inizialmente, durante la fase di modellazione del dominio, la classe OfferImpl veniva definita come segue.

    \begin{minipage}{.29\textwidth}
        \begin{figure}
            \centering
            \plantumlfile[width=.7\textwidth]{uml/grasp.pf.pre.puml}
            \caption{Diagramma UML delle classi pre refactoring}
        \end{figure}
    \end{minipage}
    \begin{minipage}{.68\textwidth}
        \begin{itemize}
            \item<1-> La classe si occupa di troppe responsabilità, violando High Cohesion. La classe dovrebbe occuparsi di:
            \begin{itemize}
                \item Gestione dell'offerta a livello di dominio
                \item Gestione della persistenza sul database
                \item Gestione dei valori degli attributi compilati
            \end{itemize}
            \item<2-> La classe inoltre viola Low Coupling essendo dipendente dalle astrazioni di Categoria e Utente oltre che alla connessione al database.
        \end{itemize}
    \end{minipage}
\end{frame}
\note{
    Il funzionamento di questa configurazione consiste in quanto segue:
    Tutto ciò contenuto nel package non viene utilizzato come dipendenza per una questione di dependency inversion e di riutilizzo.

    La classe OfferImpl viene quindi istanziata mediante l'utilizzo di una factory (correlata e presente nello stesso package) mantenendo il principio di DI per cui il codice utilizzatore vede questa una OfferFactory.

    Con questo approccio si nota come la classe OfferImpl sia responabile della gestione dei campi compilati (associati a una categoria), il loro riperimento dal database (mediante la dipendenza dalla connessione JDBC)
    e della gestione effettiva dell'offerta nella base di dati.
    
    \textbf{Note relative alla gestione dei parametri dell'offerta}

    Ogni campo compilabile viene associato a una categoria (mappa tra String e TypeDefinition), la quale definisce il nome del campo il suo tipo e l'obbligatorietà.

    Ogni tipo quindi definisce i metodi di serializzazione e deserializzazione per il salvataggio in database.

    I valori dei campi compilati sono quindi salvati con riferimento all'offerta e al campo definito nella categoria, ma questa struttura non è rispecchiata dall'architettura del codice.
}

\begin{frame}
    \frametitle{Soluzione: GRASP Pure Fabrication}
    \begin{minipage}{.48\textwidth}
        \begin{itemize}
            \item<1-> Viene segmentata la classe \texttt{OfferImpl}
            \item <2-> Vengono create le relative classi di convenienza per l'associazione al modello del database
            \item <3-> Vengono creati dei Data Abstraction Object per gestire l'interazione con il database (OrmLite)
            \item<4-> Viene delegato alla factory la responsabilità di istanziare le offerte ed effettuare l'associazione dei valori dei campi alle istanze.
        \end{itemize}
    \end{minipage}
    \begin{minipage}{.47\textwidth}
        \begin{figure}
            \centering
            \plantumlfile[width=.65\textwidth]{uml/grasp.pf.post.puml}
            \caption{Diagramma UML delle classi post refactoring}
        \end{figure}
    \end{minipage}
\end{frame}
\note{
    Si noti come le classi relative all'implementazione nel database siano presenti e ripecchino l'architettura della base di dati.

    Queste vengono gestite mediante la libreria OrmLite dal loro relativo DAO, classe che si occupa interamente della gestione della base di dati, consentendo quindi la ricerca (Query) e la gestione delle istanze.

    Come definito in precedenza, le referenze verso la rappresentazione del campo (TypeDefinition) e il suo valore vengono rappresentate dalle classi OfferFieldDB e CategoryFieldDB, la quale referenzia la rappresentazione.
}

\begin{frame}[fragile]
    \frametitle{Esempio di utilizzo DAO e classi di utilità}
    \lstset{style=java}
    \begin{lstlisting}[language=java, caption={OfferFactoryImpl\#getOffers()}]
@Override
public List<Offer> getOffers(User owner) throws DBException {
    assert owner instanceof UserImpl;
    //Controllo eseguito per aggiornare le offerte scadute
    this.checkForDueDate();
    List<OfferDB> offer_db; //Ottengo le offerte associate all'utente
    offer_db = this.offerDAO.queryForEq("owner_id", ((UserImpl) owner).getDbData());
    var offers = new LinkedList<Offer>();
    for (var offer : offer_db) {
        offers.add(this.instantiateOffer(offer, null));
    return offers;
}
    \end{lstlisting}
\end{frame}