\section{GRASP Pure Fabrication}

\begin{frame}
    \frametitle{Prima ideazione derivata dal modello di dominio}
    Inizialmente, durante la fase di modellazione del dominio, la classe OfferImpl veniva definita come segue.

    \begin{minipage}{.29\textwidth}
        \begin{figure}
            \centering
            \plantumlfile[width=.7\textwidth]{uml/grasp.pf.pre.puml}
            \caption{Diagramma UML delle classi pre refactoring}
        \end{figure}
    \end{minipage}
    \begin{minipage}{.68\textwidth}
        \begin{itemize}
            \item<1-> La classe si occupa di troppe responsabilità, violando High Cohesion. La classe dovrebbe occuparsi di:
            \begin{itemize}
                \item Gestione dell'offerta a livello di dominio
                \item Gestione della persistenza sul database
                \item Gestione dei valori degli attributi compilati
            \end{itemize}
            \item<2-> La classe inoltre viola Low Coupling essendo dipendente dalle astrazioni di Categoria e Utente oltre che alla connessione al database.
        \end{itemize}
    \end{minipage}
\end{frame}
\note{
    Si è scelto un approccio di \textbf{protected variation} per la gestione dell'implementazione delle classi di modello e della loro logica di persistenza.

    Questo per garantire stabilità anche nel caso venga cambiata l'architettura di storage.

    Nell'esempio la classe di implementazione deve occuparsi di gestire le offerte a db e, al momento della sua istanziazione, reperire dalla base di dati tutti i campi compilati associati all'offerta.

    Questo comporta che la struttura della base di dati non sia trasparente e visibile dall'architettura dell'applicativo ma sia strettamente implementata dal codice in modo non trasparente.
}

\begin{frame}
    \frametitle{Soluzione: GRASP Pure Fabrication}
    \begin{minipage}{.48\textwidth}
        \begin{itemize}
            \item<1-> Viene segmentata la classe \texttt{OfferImpl}
            \item <2-> Vengono create le relative classi di convenienza per l'associazione al modello del database
            \item <3-> Vengono creati dei Data Abstraction Object per gestire l'interazione con il database (OrmLite)
            \item<4-> Viene delegato alla factory la responsabilità di istanziare le offerte ed effettuare l'associazione dei valori dei campi alle istanze.
        \end{itemize}
    \end{minipage}
    \begin{minipage}{.47\textwidth}
        \begin{figure}
            \centering
            \plantumlfile[width=.65\textwidth]{uml/grasp.pf.post.puml}
            \caption{Diagramma UML delle classi post refactoring}
        \end{figure}
    \end{minipage}
\end{frame}
\note{
    Si noti come le classi relative all'implementazione nel database siano presenti e ripecchino l'architettura della base di dati.

    Queste vengono gestite mediante la libreria OrmLite dal loro relativo DAO, classe che si occupa interamente della gestione della base di dati, consentendo quindi la ricerca (Query) e la gestione delle istanze.

    Come definito in precedenza, le referenze verso la rappresentazione del campo (TypeDefinition) e il suo valore vengono rappresentate dalle classi OfferFieldDB e CategoryFieldDB, la quale referenzia la rappresentazione.
}

\begin{frame}[fragile]
    \frametitle{Esempio di utilizzo DAO e classi di utilità}
    \lstset{style=java}
    \begin{lstlisting}[language=java, caption={OfferFactoryImpl\#getOffers()}]
@Override
public List<Offer> getOffers(User owner) throws DBException {
    assert owner instanceof UserImpl;
    //Controllo eseguito per aggiornare le offerte scadute
    this.checkForDueDate();
    List<OfferDB> offer_db; //Ottengo le offerte associate all'utente
    offer_db = this.offerDAO.queryForEq("owner_id", ((UserImpl) owner).getDbData());
    var offers = new LinkedList<Offer>();
    for (var offer : offer_db) {
        offers.add(this.instantiateOffer(offer, null));
    return offers;
}
    \end{lstlisting}
\end{frame}
\note{
    \texttt{instantiateOffer(OfferDB main, OfferDB linked)}
    Questo metodo permette di creare una OfferImpl a partire da un OfferDB.

    Se OfferDB presenta una OfferDB collegata, il metodo si richiama ricorsivamente con le due offerte.

    Per ogni offerta, vengono reperiti i campi compilati e i relativi nomi e tipi (OfferFieldDB --> CategoryFieldDB).

    I campi vengono deserializzati e l'offerta viene istanziata e ritornata.
}