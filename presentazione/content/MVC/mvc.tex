\section{Model View Controller}

\subsection{Diagramma dei Packages}
\begin{frame}
    \frametitle{Diagramma dei package}
    \begin{figure}
        \centering
        \plantumlfile[width=.68\textwidth]{uml/mvc_classi.puml}
    \end{figure}
\end{frame}
\note{
    View è complessa ma assolutamente generalizzata, non ci sono stringhe all'interno del Controller o del Model.
    Lo strato di presentazione dipende dallo strato di business (Hierarchy usata in View è del Model)
}

\subsection{Scambio di dati}
\begin{frame}{Scambio dei dati tra gli strati}
    il modello di interazione tra i componenti \texttt{Model}, \texttt{View} e \texttt{Controller} è il seguente:

    \begin{minipage}{.49\textwidth}
        \begin{figure}
            \centering
            \plantumlfile{uml/mvc.ssd.puml}
        \end{figure}
    \end{minipage}
    \begin{minipage}{.49\textwidth}
        \begin{enumerate}
            \item<1-> Inizialmente il controller rende noto alla view le azioni disponibili.
            \item<2-> L'utente, mediante l'interazione con la view, sceglie l'azione da intraprendere
            \item<3-> Il controller riceve un callback ed esegue l'azione.
            \item <4-> Il risultato viene inviato alla view e viene mostrato all'utente mediante quanto definito nell'implementazione.
        \end{enumerate}
    \end{minipage}
\end{frame}

\begin{frame}
    \frametitle{Scelta delle azioni}

    \begin{minipage}{.49\textwidth}
        \begin{enumerate}
            \item<1-> Viene formata una lista di azioni (Istanze di controller.ReturnAction)
            \item<2-> La lista viene inviata alla view, la quale converte le istanze di controller.MenuAction in istanze di MenuEntry tramite la classe adattatore MenuEntryWrapper
            \item<3-> Viene proposta all'utente la scelta dell'azione e viene ritornata l'istanza di MenuEntryWrapper associata
            \item <4-> L'istanza viene estratta fino ad ottenere la ReturnAction iniziale
        \end{enumerate}
    \end{minipage}
    \begin{minipage}{.49\textwidth}
        \begin{figure}
            \centering
            \plantumlfile[width=.8\textwidth]{uml/mvc.menu-select.puml}
        \end{figure}
    \end{minipage}
    
\end{frame}

\begin{frame}[fragile]
    \frametitle{Esempio rappresentativo della scelta di azioni}
    \lstset{style=java}
    \begin{lstlisting}[language=java, caption={Snippet tratto da StreamView\#chooseOption()}]
@Override
public <T> MenuAction<T> chooseOption(@NotNull List<MenuAction<T>> choices, PromptType prompt) {
    return this.choose(choices.stream()
            .map((e) -> new MenuEntryWrapper<MenuAction<T>>(
                    this.conversionMap.convertMenuToString(e.getType()),
                    (in, out, ref) -> e, e.isDisabled(),
                    e.getIndex(),
                    e.getPosition()
            )).toList(), prompt);
}
    \end{lstlisting}
\end{frame}

\begin{frame}
    \frametitle{Stampa degli oggetti model}
    \begin{minipage}{.29\textwidth}
        Al fine di evitare che le classi del \texttt{Model} implementino metodi strettamente legati alla view, viene utilizzato un sistema di adapter istanziati da una factory specializzata per ogni tipologia di \texttt{View}.
    \end{minipage}
    \begin{minipage}{.69\textwidth}
        \begin{figure}
            \centering
            \plantumlfile{uml/mvc.view.getrepr.puml}
        \end{figure}
    \end{minipage}
\end{frame}
\note{
    view.DataTypeConverter è la factory dinamica che viene istanziata nel momento in cui la StreamView viene definita.

    Ogni tipo di classe appartenente al model viene registrato con un relativo adapter.

    Al momento del bisogno, dato un oggetto proveniente dal model, viene istanziata una istanza dell'adapter alla quale viene passata la referenza dell'oggetto, per poi chiamate il metodo ereditato dall'interfaccia StreamDataType getStreamRepresentation() per ottenere il valore stampabile come stringa.

    È un tostring più grosso.
}
